\chapter{State Space and Action Space Representation}

This chapter contains a discussion about the possible ways of representing the important properties of the abstraction of the world in which the autonomous vehicle will perform computations in order to achieve its goal.

We will discuss namely the state space of the vehicle, the space of possible actions, and the way we will consider the temporal nature of the problem.

\section{State Space}

We can represent this state of the vehicle with a configuration $( \, \vec{x}, \vec{v}, \alpha, \theta ) \,$, where $\vec{x}$ is the position vector, $\vec{v}$ is the vector of the instantaneous velocity, $\alpha$ is the steering angle of the front wheels, and $\theta$ is the orientation of the vehicle.

The difference between the orientation of the vehicle and the angle of the velocity is called the slip angle. We assume that only the front wheels can be steered as it is common for most car-like vehicles.

\section{Vehicle Control Actions}

To control the vehicle, we must be able to to control its longitudal and lateral velocities. Robots can be divided into two basic classes of holonomic and non-holonomic driving robots.

\paragraph{Holonomic} drive robots have the number of degrees of freedom of movement equal to the total number of the degrees of freedom \cite{}. A robot with holonomic drive can move in any direction it needs to. An example of holonomic drive can be robots with omni-wheels or castor wheels.

\paragraph{Non-holonomic} drive robots on the other hand have a smaller number of degrees of freedom than the total number of degrees of freedom. There are three degrees of freedom for a robot in a 2D environment: its position in the two axes and its orientation. Car-like robots have only two controllable degrees of freedom though: the acceleration (positive or negative) which moves the robot parallel to the direction of its orientation, and changing the angle of its wheels. This limitation results in a more complex turning maneuvers when compared to the holonomic drive robots.

We will assume that our car-like robot has a non-holonomic drive and that it is able to change only the steering angle of its front wheels, not the rear. Most of the personal cars in operation as of writing this thesis are constructed in this way and we would like to test our algorithms on a robot which has similar driving characteristics to the common real world cars.

The vehicle is moving continuously in the environment and potentially at high speeds. Any action we will apply to the vehicle cannot change the velocities instantaneously and directly. Actions will be used to control the actuators of the vehicle and these will create forces which will cause the changes of movement of the vehicle.

A typical car-like vehicle has a way of adjusting the longitudal velocity by applying throttle or by breaking. We assume that the vehicle has only front wheel steering and the rear tires are fixed and always aligned with the orientation vehicle.

We define an action as a pair $( \, t, \phi ) \,$ where $t \in [ \, -1, 1 ] \,$ is the amount of applied throttle ($-1$ is full reverse, $0$ is no throttle, $1$ is full forward throttle) and $\phi$ is the desired steering angle of the front wheels ($-1$ is the maximum angle to the left, $0$ is the orientation of the vehicle, $1$ is the maximum angle to the right). To achieve breaking an action with the required amount of throttle with an opposite sign to the direction of motion should be used.

When this abstraction is applied to a specific hardware platform it should be possible to reduce the number of the actions because of hardware limitations. The actuators do not have infinite resolution and thus the $( \, -1, 1 ) \,$ interval can be divided into a constant number of subintervals which correspond to the same amount of throttle or the same steering angle. This means that the number of actions is reduced to $mn$ where $m$ is the number of different steering angle and $n$ is the number of different throttle levels the actuators can achieve.

This gives us a finite and discrete set of actions we can use to control the motion of the vehicle.

\section{Time Representation}

The actions described in the previous section do not have any intrinsic representation of time. If we created a plan as a sequence of these actions, we would have hard time executing them as we would not know at which time to apply these actions. And the timing of these actions is very important as it has significant implications for the state of the vehicle.

Our actions do not change the state of the vehicle (position, velocity, orientation) directly but through the use of actuators (acceleration, steering angle). By applying the same acceleration for two different time periods, we achieve two different velocities of the vehicle.

We should also consider hardware limitations of the actuators of a vehicle. It takes some time $t_{adj} > 0$ for them to switch from the previous action to the new action. It should be obvious that this time period is not constant and will differ for different pairs of actions based on the amount of change in the. We can imagine this as the time it would take a human driver to turn the steering wheel and press the accelerator paddle into the desired position.

The first way how to deal with this problem would be to add another parameter $t \in ( \, t_{adj}, \infty ) \,$ which would describe the time period in seconds for which the action should be applied.

A second way might be to choose a constant time period $t_{const} \in ( \, t_{adj}, \infty ) \,$ in seconds for every action. This implicit representation of time would keep the actions simple and reduce the number dimensions of the search space for the planning algorithm. On the other hand we might need to repeat one action several times to achieve the same maneuvers which could be achieved by one longer action (e.g. a U-turn maneuver) and the resulting plans will be longer.

We can address this problem by compressing the plan by merging repeating actions into a single action and a discrete parameter $r \in { \, 2, 3, 4, ..., r_{max} } \,, r_{max} \in \natural$ which will describe how many times the action should be repeated. This will shift our representation of time towards the first approach, but will still keep the action space discrete and finite.

For the sake of simplicity we will use the implicit representation of time with the compression of repeating actions. We will also assume that $t_{adj}$ is close to zero and we will assume that the changes of actions are immediate.